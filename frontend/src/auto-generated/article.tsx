/** Autogenerated from markdown files using mdx-parser deno script */
import React, { FunctionComponent } from 'react';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { atomOneDark } from 'react-syntax-highlighter/dist/esm/styles/hljs';
import ReactPlayer from 'react-player';

interface CompProps {
  videoW?: number;
  videoH?: number;
}

const articles: { [fileName: string]: FunctionComponent<CompProps> } = {
  'demystifying-javascript-closures': () => (
    <div className="mb-32">
      <h1>Demystifying JavaScript Closures</h1>
      <div>
        <p>
          For a long time, I've perceived closures as this arcane topic that had
          a tendency to unnerve me. However, it is a powerful feature of
          JavaScript that lets you do some neat stuff. In this article, I will
          cover its basics, and we will look at one practical usage, and
          hopefully you will find it intelligible as well (if you don't
          already).
        </p>
        <h2>The core of JavaScript</h2>
        <p>
          JavaScript is a single-threaded language. This means that it can only
          run/execute one piece of code at a time and must finish it, before
          executing the next bit. Put simply, it cannot multi-task. Put
          technically, it has,
        </p>
        <ul>
          <li>One Thread of Execution</li>
          <li>One Memory Heap</li>
          <li>One Call Stack</li>
        </ul>
        <p>
          The <strong>thread of execution</strong> basically refers to
          JavaScript's thread, going line by line over your code and executing
          each line. There is a caveat to this however. If a function is
          encountered, JavaScript will declare the function in memory and move
          to the next line after the function. It will not go into the body of
          the function until a function call is encountered. Once the function
          completes, it will then jump back (return) to the line that initially
          called the function.
        </p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/kzbawqhavtrcrf4vmhvf.png"
          alt="Thread of execution"
        />
        <p>
          Before your code starts to run, a global execution context is created
          with a memory heap. An execution context is the environment in which
          your thread of execution runs.
        </p>
        <p>
          Every time your thread of execution enters an execution context, this
          context is pushed onto your call stack. Therefore, when your code
          starts to run initially, global context is pushed onto the call stack,
          and the JavaScript compiler encounters LINE 1.
        </p>
        <p>
          It takes the entire function definition (along with the code) and
          stores it in the <strong>memory heap</strong>. It does not run any of
          the code inside the function.
        </p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/b90rf5jjarsb6tzwhtsm.png"
          alt="Call Stack and Memory Heap"
        />
        <p>
          The next line in the order of execution is LINE 6, where the function
          is called (or invoked). When a function is called, a new execution
          context is created and pushed onto the stack. It is at this point,
          that JavaScript enters inside the function to execute the function
          body (LINE 2).
        </p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/u9ypmb24y0f2l59utmwe.png"
          alt="Function call"
        />
        <p>
          It is also interesting to note that LINE 6 has not completed its
          execution though (result is still uninitialized), it is now waiting
          for the function to complete its execution at which point the
          `addOne()` context is popped off the stack and destroyed. Before
          destruction however, it will return the calculated value back to LINE
          6 and initialize the value of result.
        </p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/1f30859d8hnoar0zopar.png"
          alt="Final State"
        />
        <h2>Where do closures come into the picture?</h2>
        <p>
          Now, I mentioned in the previous paragraph that the execution context
          of `addOne()` is destroyed after the function has completed its
          execution. So there is no label called "val" in our memory with a
          value initialized to it anymore. Its all been completely removed from
          memory.
        </p>
        <p>
          This behavior is a good thing, because each time we run our function
          with different arguments, we don't typically need to know what values
          the function was previously run with or what intermediate values were
          generated during execution. But, there are some cases where having
          memory attached to our function definition that persists across
          execution will prove to be a powerful capability that lets us do
          incredible things.
        </p>
        <h2>Attaching memory to function</h2>
        <p>Let's look at some code,</p>
        <SyntaxHighlighter language="javascript" style={atomOneDark}>
          {`function createAddFunction(n) {
  function addByN(val) {
    return val + n;
  }
  return addByN;
}

const addBy10 = createAddFunction(10);
console.log(addBy10(2));

`}
        </SyntaxHighlighter>
        <p>
          Here we have a function, `createAddFunction` which takes a parameter
          `n` and returns a function called `addByN`. Let's break this down.
          When the compiler starts, it creates a global context, and encounters
          LINE 1 where it defines a label in memory (called `createAddFunction`)
          and stores the entire function definition under this label.
        </p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/r2bbbsatb958pdsxlgv4.png"
          alt="createAddFunction defined"
        />
        <p>
          Next, it creates a label in memory called `addBy10` which remains
          uninitialized till the function call `createAddFunction()` finishes
          execution and returns. When this function gets executed, it creates a
          new execution context and pushes this on to the stack. Since we pass
          the value `n` as 10, this gets stored in the `createAddFunction`
          context. In the function body, it also defines `addByN` function to be
          stored in memory.
        </p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/4e0q1kklxssiaio89x1g.png"
          alt="createAddFunction execution"
        />
        <p>
          Then it returns this function `addByN` to be stored as initial value
          for `addBy10` label in memory. Once the value has been returned, the
          `createAddFunction` execution context is popped off the call stack and
          destroyed.
        </p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/uo4p9qjh8ciu1pcqxcps.png"
          alt="createAddFunction complete"
        />
        <p>We then invoke the function `addBy10(2)` with an argument `2`.</p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/061unjliklurkixn73tv.png"
          alt="addBy10 definition"
        />
        <p>
          Our `addBy10` function would be defined as above. It's the same as our
          `addByN` function except it is now stored under a different label in
          memory. Here comes the kicker. The parameter `val` takes on the value
          2, but what is the value of `n` ? Its not defined inside our function,
          nor is it defined in our global execution context. Furthermore, there
          are no other execution contexts left because `createAddFunction`
          context was destroyed. At this point, we would expect `n` to be
          undefined, but its not. Thanks to how JavaScript behaves in these
          circumstances because of closures. Our function somehow remembers that
          the value of `n` at the time of function creation was `10` and thus we
          can say, our function has persistent memory.
        </p>
        <h2>Lexical Scoping and Closures</h2>
        <p>
          Scope is the set of rules in a programming language that dictates what
          data is available to the compiler within a particular execution
          context. JavaScript has the scope rule of Lexical / Static Scoping.
          Lexical Scoping is a description of how the JavaScript compiler
          resolves variables names when you have functions nested. That is, the
          parent of a function determines what data that function has access to
          (in addition to the data that is local to the function).
        </p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/ryb65wc33adb5vniaw1i.png"
          alt="Lexical Scoping"
        />
        <p>
          When the thread of execution is inside the inner execution context, it
          has access to variables defined in the outer execution context via our
          scoping rule.
        </p>
        <p>
          So, when the `addByN` function is returned from the
          `createAddFunction` execution context, it takes along with it all the
          variables that it has access to. Because of lexical scoping, this
          includes the key-value pair of `n` and `10`. This is called a closure.
          _A closure is the combination of a function, and the lexical
          environment within which that function was declared_
        </p>
        <img
          src="https://dev-to-uploads.s3.amazonaws.com/i/l3hfkfeh0gxk9vcthpn2.png"
          alt="Closure"
        />
        <p>
          So, our label `addBy10` is not merely a reference to a function
          anymore, but a reference to a function and a data store (that persists
          before, during and after the function call).
        </p>
        <p>
          It is important to note that this value of `n = 10` cannot be accessed
          in any other way but by calling the function and this usage depends on
          how the function was originally defined. Hence, it is protected
          persistent data.
        </p>
        <h2>Iterators using closures</h2>
        <p>
          A good example for closures is iterators in JavaScript. An iterator is
          an object which defines a sequence of values that can be accessed by
          having a `next()` method which returns an object with two properties:
          `value` (next value in the sequence) and `done` (boolean to track
          whether sequence has already been iterated over).
        </p>
        <p>
          If we try to implement a simple iterator, we can see the usage of
          closures.
        </p>
        <SyntaxHighlighter language="javascript" style={atomOneDark}>
          {`const makeIterator = (arr) => {
  let currentIndex = 0;

  return {
    next: () => {
      if (currentIndex < arr.length) {
        return {
          value: arr[currentIndex++],
          done: false,
        };
      }

      return {
        value: arr[currentIndex++],
        done: true,
      };
    },
  };
};

`}
        </SyntaxHighlighter>
        <p>
          The makeIterator function creates/makes an iterator object and returns
          it. This can be used as follows:
        </p>
        <SyntaxHighlighter language="javascript" style={atomOneDark}>
          {`const iterator = makeIterator([1, 2, 3]);
let result = iterator.next();
while (!result.done) {
  console.log("RESULT", result.value);
  result = iterator.next();
}

`}
        </SyntaxHighlighter>
        <p>
          We had to use a closure in this case because we needed to store (in
          memory) and track the currentIndex across the `next()` function calls
          as we consume our iterator.
        </p>
        <p>
          Some other places where closures are used are in the implementation of
          generators, promises etc. It can also be used in functions that
          perform large computations to store previous computations in order to
          not repeat it if the same arguments are passed in (memoization).
          Closures provide you a powerful toolkit to writing modular optimized
          code. I hope that with this information you are able to leverage the
          power of closures to write better code.
        </p>
      </div>
    </div>
  ),

  'devlauncher-hackathon-experience': ({ videoW, videoH }) => (
    <div className="mb-32">
      <h1>5 Takeaways From My First Hackathon Experience</h1>
      <div>
        <p>
          Last week, I took part in my first ever Hackathon and I presented a
          tool called <strong>DevLauncher</strong>, and I'm excited to share
          that I won the event. I had a couple of takeaways from the experience,
          and I will share them in this article.
        </p>
        <p>
          If you would like to see the results of the hackathon, you can check
          them out{' '}
          <a
            className="underline"
            href="https://start.devspaces.com/devspaces-hackathon/#winners1"
            target="_blank"
          >
            here on this link
          </a>
          .
        </p>
        <p>You can also see my submission/demo video below:</p>
        <div className="mt-8">
          <ReactPlayer
            url="https://www.youtube.com/watch?v=Sr9YMOj4j48"
            width={videoW || 1000}
            height={videoH || 560}
          />
        </div>
        <p>
          The category of the event was to find ways to improve team
          productivity by building extensions, or developing a workflow, with a
          new product called <strong>DevSpaces</strong>. DevSpaces is a tool to
          launch new environments from Github and start to code within seconds
          of your first time looking at a repository.
        </p>
        <p>
          Setting up a new project on your local (even with good README's) can
          be painful, especially if you're new to that particular technology.
          Typically, I've seen that new developers tend to take about a week
          before they can hit the ground running by adding new capability to the
          application. So, DevSpaces can be an effective{' '}
          <strong>ease-into-the-codebase solution</strong> for onboarding new
          developers. It can also be really helpful for code reviewers to check
          out the context of how the code in the PR works{' '}
          <strong>without having to switch context</strong> from their current
          work on their local machines.
        </p>
        <p>
          So, this was a product that the senior leadership was really excited
          about. A series of Hackathons were announced to promote and integrate
          the usage of the product into the different teams in the organization.
        </p>
        <h2>Understand the Hackathon objective</h2>
        <img
          src="https://s3.amazonaws.com/code-ninja.xyz/assets/devlauncher-hackathon-experience/event-objective.png"
          alt="Event Objective"
        />
        <p>
          While this seems obvious, its something I generally miss if I'm not
          consciously thinking about this. I skimmed through all the info and
          videos that the product had, as well as all info about the Hackathon,
          to better understand the objective. I determined the primary objective
          of the Hackathon was to get teams to adopt the product and find ways
          to be more productive with the tool. They were looking for the tool
          with the most impact. The most impact not just for your team, but a
          solution thats extensible to other teams as well (even those working
          in a different tech stack).
        </p>
        <p>
          I realized that every team which uses the product would like to set up
          their environment (be it CloudFormation or any other kind of
          environment) because that is the single most important value
          proposition of the product. When working in a local terminal / IDE, we
          tend to look at our situation and determine what kind of setup we
          want. This was not directly feasible with DevSpaces because you could
          have only one config file (for example, we don't have config.prod.json
          vs config.dev.json). This was the problem I wanted to solve to enable
          developers to choose different setups for different situations.
        </p>
        <h2>Understand your objectives</h2>
        <img
          src="https://s3.amazonaws.com/code-ninja.xyz/assets/devlauncher-hackathon-experience/your-objective.png"
          alt="Your Objective"
        />
        <p>
          This is different from the previous point, because you can have very
          different objectives from the intention of the event organizers. This
          being my first hackathon, I didn't really think about winning it. I
          just wanted to be able to complete an end-to-end tool/solution that
          fits the theme and submit it. The objective was to participate more
          than attempt a grandiose high-impact idea that could (perhaps) not be
          achieved in the given time frame. The other objective, was to come out
          of the other end with a tool that I would end up using on a day-to-day
          basis going forward. This would ensure that there is a benefit to my
          effort even if I don't really win anything.
        </p>
        <p>
          I think having this mindset provided me with the necessary motivation
          to pull long hours over the weekend since my target was achievable
          with certainty and had a sure benefit.
        </p>
        <h2>Run a feasibility study</h2>
        <img
          src="https://s3.amazonaws.com/code-ninja.xyz/assets/devlauncher-hackathon-experience/feasibility-study.png"
          alt="Feasibility Study"
        />
        <p>
          Given the time constraint of a hackathon (~ 3/4 days effectively), you
          don't have the possibility to explore ideas that don't pan out at the
          end due to technical limitations. So, its very important to identify
          the feasibility of ideas as soon as possible. As soon as the
          brainstorming phase is done, identify what are critical points in your
          plan that need to be tested for feasibility. Ideally, brainstorm a
          couple of different ways of solving the same problem you identified.
        </p>
        <p>
          For my problem, I tested the feasibility of developing the solution
          with an electron desktop app shell or a chrome extension. Both were
          feasible to develop my solution, but chrome extension felt natural and
          made more sense. Another critical point of testing was to identify if
          DevSpaces had any open API that I could communicate with from my
          application. It did not, which was a huge blocker. I looked into the
          docs to find that you could pass environment variables as part of the
          URL. With this I could develop a solution that could solve the core
          problem I had, but I still had to scrap a few other ideas I had
          because of the no public API limitation.
        </p>
        <p>
          Having run the feasibility and tweaked my plan a little, I felt that I
          had enough to actually start the project.
        </p>
        <h2>
          Setup a minimal project with only tooling that adds to individual
          productivity
        </h2>
        <img
          src="https://s3.amazonaws.com/code-ninja.xyz/assets/devlauncher-hackathon-experience/minimal-tooling.png"
          alt="Minimal Tooling"
        />
        <p>
          Another important consideration is to identify your repo setup. Given
          that I was working on the project alone, I had to choose tooling
          taking this into account. For example, I chose to build the extension
          using React over Angular, because it comes with a simpler setup
          (especially beneficial for non-production applications). I chose
          parcel over webpack because I knew parcel was sufficient for my
          use-case. I only needed babel conversion and static files copy. So, it
          would be faster to develop with parcel.
        </p>
        <p>
          Although I am a <strong>huge</strong> typescript fan, I decided
          against writing the application in typescript because maintaining
          types and interfaces is more overhead with little to no benefit. Given
          that I was going to work solo on the project in a short time, I always
          have the context of the entire app and types dont really add that much
          value. Similarly, I decided not to set up linters or formatters except
          for prettier and I decided to use Material UI to quickly build
          components.
        </p>
        <h2>Hardcode or hack non-critical features</h2>
        <img
          src="https://s3.amazonaws.com/code-ninja.xyz/assets/devlauncher-hackathon-experience/hack-non-criticals.png"
          alt="Hack your non-critical"
        />
        <p>
          Given that your point is to demonstrate the critical features of the
          application / tooling, it is probably not a good idea to spend time
          building the necessary but non-critical features. Find ways to hack or
          hardcode some things as per your situation so that you can focus on
          the critical stuff.
        </p>
        <p>
          For example, I needed an AWS user with permissions for some features,
          but instead of building a full-scale auth solution, I just registered
          a cognito user to my identity pool and used a simple sign-in form.
          This way the tool is still usable on a day-to-day basis, and you can
          add on proper auth setup at any time.
        </p>
        <p>
          Another example would be, I hardcoded my environment values for just
          my environments "ash1" and "ash2", meaning you don't have the ability
          to add more environments or associate your environments with your
          cognito user. But this is not critical for your demonstration, because
          if it works for two, it would work for N number anyway.
        </p>
        <h2>That's all, folks!</h2>
        <p>
          I learnt a ton participating in the event, the top 5 are what I've
          listed above. I would love to hear from you if you disagree on any of
          my points or have any thoughts on how to go about being more efficient
          in developing solutions for hackathons. Hit me up on LinkedIN. :)
        </p>
      </div>
    </div>
  ),
};
export default articles;
